#+TITLE: My orgmode setup
#+PROPERTY: header-args:elisp :tangle doom.d/config.el :padline no
#+TAGS: fix(b) feat(f) doc(d) chore(c) to_think(t)
#+TAGS: noexport

* Intro :noexport:
#+begin_src elisp
;;; $DOOMDIR/config.el --- Doom-emacs configuration file
;;; Commentary:
;;; Code:

(setq user-full-name "Vladimir Timofeenko"
      user-mail-address "id@vtimofeenko.com")
(setq doom-font (font-spec :family "JetBrainsMono Nerd Font" :size 12))
(setq doom-theme 'doom-one)
(setq display-line-numbers-type 'relative)
;; Configure the terminal cursor to change
(use-package! evil-terminal-cursor-changer
  :hook (tty-setup . evil-terminal-cursor-changer-activate))
;; Make the line numbers more visible
(custom-set-faces!
  '(line-number-current-line :foreground "#9A70A4")
  '(line-number :foreground "#A1A19A")
  )
(setq ispell-personal-dictionary "~/.cache/aspell.pws")
(defun zz/org-download-paste-clipboard (&optional use-default-filename)
  (interactive "P")
  (require 'org-download)
  (let ((file
         (if (not use-default-filename)
             (read-string (format "Filename [%s]: "
                                  org-download-screenshot-basename)
                          nil nil org-download-screenshot-basename)
           nil)))
    (org-download-clipboard file)))
(when (eq system-type 'darwin)
  ;; https://github.com/nobiot/org-transclusion/issues/52
  (advice-remove 'org-link-search '+org--recenter-after-follow-link-a)
  (use-package! org-transclusion
    :after org
    :init)
  (require 'ejc-sql)
  (setq nrepl-sync-request-timeout 60)
  (setq clomacs-httpd-default-port 8090) ; Use a port other than 8080.
  (after! org
    (add-to-list 'org-structure-template-alist
                 '("sql" . "src sql :exports both :eval no-export\n"))))
;; Add lines of context
(setq scroll-margin 5)
;; Automatically format .nix files on save
(add-hook 'nix-mode-hook 'nixpkgs-fmt-on-save-mode)
;; Add custom surround for nix multiline variables
(after! evil-surround
  (let ((pairs '((?m "''\n" . "\n''"))))
    (prependq! evil-surround-pairs-alist pairs)
    (prependq! evil-embrace-evil-surround-keys (mapcar #'car pairs))))
(setq datetime-timezone #'US/Pacific)
;; A very simple semantic commits implementation
;; Queries the user for the issue type and inserts it
(define-derived-mode vt-git-commit-mode text-mode "Git commit"
  (save-match-data
    (when (save-excursion (re-search-forward "\\`[\n[:space:]]*#" nil :noerror))
      (let (
            (committype (completing-read "Choose semantic commit type: "
                                         '("fix" "feat" "chore" "doc") nil t)))
        (save-excursion
          (insert (format "%s: \n" committype)))))))

(setq git-commit-major-mode 'vt-git-commit-mode)
#+end_src
* Orgmode config
** Intro :noexport:
#+begin_src elisp
(after! org
  (setq calendar-week-start-day 1)
  (setq org-log-done 'time)
  (setq org-log-into-drawer "LOGBOOK")
  ;; More intuitive link opening
  (map! :leader
        (
         :prefix-map ("l" . "link")
         :desc "Open link at cursor" "o" #'org-open-at-point
         )
        )

  (setq org-archive-location ".archive/%s_archive::")
  ;; Jump back-forth between visible headers
  (map! :leader
        (:desc "Next visible heading" "]" #'outline-next-visible-heading)
        )
  (map! :leader
        (:desc "Previous visible heading" "[" #'outline-previous-visible-heading)
        )
  (setq org-download-method 'directory)
  (setq org-download-image-dir "images")
  (setq org-download-heading-lvl nil)
  (setq org-download-timestamp "%Y%m%d-%H%M%S_")
  (setq org-image-actual-width 300)
  (map! :leader
        :prefix-map ("v" . "paste")
        (:desc "Paste image from clipboard" "i" #'zz/org-download-paste-clipboard))
  (add-to-list 'org-modules 'org-habit)
  (set 'org-habit-show-all-today t)
#+end_src
** General philosophy

This is mostly written to organize my own thoughts into some coherent narrative so that I stop stumbling over my own shoelaces with ad-hoc configuration.

This is done on top of a pretty vanilla doom-emacs configuration.

** GTD process implementation

*** *Capture* anything that crosses your mind, nothing is too big or small

As someone who uses orgmode to organize both my professional and personal life, I have four categories of incoming information:

1. Tasks, containing some action to be done
2. Notes, generally not actionable, or for future reference
3. Meetings, for which notes should be taken
4. Appointments, which are set sometime in the future

The difference between the middle two is that for meetings I usually want to capture additional meta information, like when the meeting took place and who attended it.

The three kinds of incoming information should easily distinguishable. To that end, there are two mechanisms:

1. Keywords which denote the state of the task
2. Tags

I will be using a limited amount of TODO states, only tasks will have a keyword.

Meetings will be marked as ":meeting:" tag and have no keyword assigned.

Notes will not have a keyword or a tag at their creation.

Tasks and notes will have a property that captures when they were created.

#+begin_src elisp
(setq org-capture-templates
      `(("t" "Task" entry (file "inbox.org")
         ,(string-join '("* TODO %?"
                         ":PROPERTIES:"
                         ":CREATED: %U"
                         ":END:")
                       "\n"))
       ("n" "Note" entry (file "inbox.org")
         ,(string-join '("* %?"
                         ":PROPERTIES:"
                         ":CREATED: %U"
                         ":END:")
                       "\n"))
        ("m" "Meeting" entry (file "inbox.org")
         ,(string-join '("* %? :meeting:"
                         "<%<%Y-%m-%d %a %H:00>>"
                         ""
                         "/Met with: /")
                       "\n"))
        ("a" "Appointment" entry (file "inbox.org")
         ,(string-join '("* %? :appointment:"
                         ":PROPERTIES:"
                         ":CREATED: %U"
                         ":END:")
                       "\n"))
        ))
#+end_src

**** Task states

In the spirit of simplicity, I will be using a limited set of task states:

- TODO :: to be done in future
- STRT :: being done right now
- HOLD :: cannot proceed, needs some external blocker
- DONE :: terminal state, task is done
- CNCL :: terminal state, task canceled

#+begin_src elisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "STRT(s)" "HOLD(h)" "|" "DONE(d)" "CNCL(c)")))
#+end_src

With their semantic meanings expressed by org-todo-keyword-faces:
#+begin_src elisp
(setq org-todo-keyword-faces '(("STRT" . +org-todo-active)
                               ("HOLD" . +org-todo-onhold)
                               ("CNCL" . +org-todo-cancel)))
#+end_src

*** *Clarify* what you've captured into clear and concrete action steps.

Clarification step involves two parts:

1. Locating objects to clarify
2. Editing an item for clarity, potentially breaking it into several items

The first point will be implemented by a custom entry in ~org-agenda-custom-commands~:

#+begin_src elisp
(setq org-agenda-custom-commands
      '(("g" "Get Things Done (GTD)"
         ;; Only show entries with the tag "inbox" -- just in case some entry outside inbox.org still has that file
         ((tags "inbox"
                ((org-agenda-prefix-format "  %?-12t% s")
                 ;; The list of items is already filtered by this tag, no point in showing that it exists
                 (org-agenda-hide-tags-regexp "inbox")
                 ;; The header of this section should be "Inbox: clarify and organize"
                 (org-agenda-overriding-header "\nInbox: clarify and organize\n")))))))
#+end_src

"Editing an item for clarity" is a bit more ambiguous term, since "clear" and "concrete" are hard to measure in technical terms.

However, there are a couple of technical steps that can be taken:

   1. Tasks can have an estimate, making it easier to pack into period when planning them. If I have an hour of free time - probably no point in tackling something that takes 2 hours to complete.

      A list of estimates that can used will be specified in ~inbox.org~ as:

      #+begin_src org
      #+PROPERTY: Effort_ALL 0 0:05 0:10 0:15 0:30 0:45 1:00 2:00 4:00
      #+end_src

      Since this value is specified in the inbox.org file and org-capture-templates are added there - it's possible to estimate effort directly when capturing a task.

   2. Make a captured task and note link back to the context they were taken in.

      I will be using ~add-to-list~ to shadow the previous values in ~org-capture-templates~. The new versions of a task and note will have an extra line linking to the context they were taken in (placeholder ~%a~)

      The downside of this approach is that "t" and "n" appear twice in capture list, but it's only cosmetic.

      #+begin_src elisp
(add-to-list 'org-capture-templates
             `("t" "Task" entry (file "inbox.org")
               ,(string-join '("* TODO %?"
                               ":PROPERTIES:"
                               ":CREATED: %U"
                               ":END:"
                               "/Context:/ %a")
                             "\n"
                             )))
(add-to-list 'org-capture-templates
             `("n" "Note" entry (file "inbox.org")
               ,(string-join '("* %?"
                               ":PROPERTIES:"
                               ":CREATED: %U"
                               ":END:"
                               "/Context:/ %a")
                             "\n")))
      #+end_src



**** TODO [#A] List tasks with huge(>1h) efforts as candidates for breaking down into smaller chunks :feat:

**** TODO Create a t-shirt size mapping with Effort_ALL :feat:

I prefer XSmall, Small, Medium, Large, XLarge approach to effort estimates. In Youtrack I have created a mapping between the two. Would be convenient to have it in the orgmode.

**** TODO Consider "CREATED" prop for headings entered inline. :to_think:

[[https://stackoverflow.com/questions/12262220/add-created-date-property-to-todos-in-org-mode][Here's]] an implementation of this

**** TODO [#C] Fix extra entries in capture list :fix:

There are duplicates in the capture list because of add-to-list behavior. Not very important since only cosmetic.

*** *Organize* and put everything into the right place.

1. The end-result of organization - empty inbox
2. Tasks get refiled into specific projects
3. Tasks that don't map to a project go to a special section of agenda
4. Meetings get refiled into journal inside agenda
5. Notes get refiled into specific project
6. Notes without a project go to notes.org

Since I could not make the setup below work, the refiling is just something I will have to do mentally.

**** TODO Context-dependent refile targets :feat:
Implementation of this approach would require context-dependent refile targets -- something that is not present in default emacs. However, it can be exnteded to support this (source: [[https://emacs.stackexchange.com/questions/24976/org-mode-can-you-set-up-context-dependent-refile-targets][StackOverflow]]):

#+begin_src elisp :tangle no
(require 'dash)

(defvar org-refile-contexts "Contexts for `org-capture'.

Takes the same values as `org-capture-templates-contexts' except
that the first value of each entry should be a valid setting for
`org-refile-targets'.")

(defun org-refile--get-context-targets ()
  "Get the refile targets for the current headline.

Returns the first set of targets in `org-refile-contexts' that
the current headline satisfies, or `org-refile-targets' if there
are no such."
  (or (car (-first (lambda (x)
                     (org-contextualize-validate-key
                      (car x)
                      org-refile-contexts))
                   org-refile-contexts
                   ))
      org-refile-targets)
  )

(defun org-refile-with-context (&optional arg default-buffer rfloc msg)
  "Refile the headline to a location based on `org-refile-targets'.

Changes the set of available refile targets based on `org-refile-contexts', but is otherwise identical to `org-refile'"
  (interactive "P")
  (let ((org-refile-targets (org-refile--get-context-targets)))
    (org-refile arg default-buffer rfloc msg)
    ))
#+end_src

Now, to implement the requirements at the beginning of this section:

#+begin_src elisp
(setq org-refile-contexts
      '((((("inbox.org") . (:regexp . "Projects"))) ;; example
         ((lambda () (string= (org-find-top-headline) "Inbox")))
         )
        ;; 6: Notes without a project go to notes.org
        (((("inbox.org") . (:regexp . "Notes")))
         ;;((lambda () (string= (org-element-property :my_type (org-element-at-point)) "NOTE")))
         ((lambda () ('regexp ":my_type:")))
         )
        ))
#+end_src

Journal-like results could be achieved through ~(file+olp+datetree)~

*** *Review*, update, and revise your lists.

The idea behind the implementation is to create a view to help move tasks along from triage, into refiled into started and ultimately done.

When showing the "Can be done" list, it's useful to have a quick reference to the day's agenda to see if I can actually fit something.

#+begin_src elisp
(setq org-agenda-files (list "inbox.org" "agenda.org"
                             "notes.org" "projects.org"))
(setq org-agenda-custom-commands
      '(("g" "Get Things Done (GTD)"
         ;; Only show entries with the tag "inbox" -- just in case some entry outside inbox.org still has that file
         ((tags "inbox"
                ((org-agenda-prefix-format "  %?-12t% s")
                 ;; The header of this section should be "Inbox: clarify and organize"
                 (org-agenda-overriding-header "\nInbox: clarify and organize\n")))
          ;; Show tasks that can be started and their estimates, do not show inbox
          (todo "TODO"
                ((org-agenda-skip-function
                  '(org-agenda-skip-entry-if 'deadline 'scheduled))
                 (org-agenda-files (list "agenda.org" "notes.org" "projects.org"))
                 (org-agenda-prefix-format "  %i %-12:c [%e] ")
                 (org-agenda-max-entries 5)
                 (org-agenda-overriding-header "\nTasks: Can be done\n")))
          ;; Show agenda around today
          (agenda nil
                  ((org-scheduled-past-days 0)
                   (org-deadline-warning-days 0)))
          ;; Show tasks on hold
          (todo "HOLD"
                ((org-agenda-prefix-format "  %i %-12:c [%e] ")
                 (org-agenda-overriding-header "\nTasks: on hold\n")))
          ;; Show tasks that are in progress
          (todo "STRT"
                ((org-agenda-prefix-format "  %i %-12:c [%e] ")
                 (org-agenda-overriding-header "\nTasks: in progress\n")))

          ;; Show tasks that I completed today
          (tags "CLOSED>=\"<today>\""
                ((org-agenda-overriding-header "\nCompleted today\n"))))
         (
          ;; The list of items is already filtered by this tag, no point in showing that it exists
          (org-agenda-hide-tags-regexp "inbox")))
        ("G" "All tasks that can be done"
         ((todo "TODO"
                ((org-agenda-skip-function
                  '(org-agenda-skip-entry-if 'deadline 'scheduled))
                 (org-agenda-files (list "agenda.org" "notes.org" "projects.org")) (org-agenda-prefix-format "  %i %-12:c [%e] ")
                 (org-agenda-overriding-header "\nTasks: Can be done\n")))
          (agenda nil
                  ((org-scheduled-past-days 0)
                   (org-deadline-warning-days 0)))))))
#+end_src

To show the agenda in a more compact manner and skip a time line when something is scheduled:

#+begin_src elisp
(setq org-agenda-time-grid
  '((daily today require-timed remove-match)
    (800 1000 1200 1400 1600 1800 2000)
    "......"
    "----------------"))
#+end_src

When something is scheduled for a specified time slot (08:00, 10:00, etc.), only the scheduled item will be shown, not the full "08:00 ... ..." line.

**** DONE Remove scheduled tasks from 'can be done' :fix:
CLOSED: [2022-10-07 Fri 12:26]

**** DONE [#A] Sort 'can be done' tasks by priority :feat:
CLOSED: [2022-10-11 Tue 11:48]

The current default sorting is sufficient

**** TODO [#C] Rewrite this using add-to-list to maintain coherency in tangled file :chore:

**** TODO [#C] Add periodic tasks that were complete today to the list of complete tasks :feat:

**** CNCL Show task with duration as a continuous block :feat:

Maybe like [[https://emacs.stackexchange.com/questions/5395/show-free-blocks-of-time-in-org-modes-agenda][so]]?

Not sure how it's implementable now, but with the ~org-agenda-time-grid~ config is slightly better

**** TODO Do not show tasks under a project that is on HOLD :feat:

Applies to both "g" and "G" views.

If I put a project on pause - I don't need to see its tasks

**** TODO Add a view only for projects and their states :feat:

Just include top-level headlines from the ~projects.org~ and their states. Maybe percentage of tasks if I can figure out how to do it.

**** TODO Add effort/clocks to "Completed today" :feat:

**** TODO Show recurring tasks that were completed today :feat:

*** *Engage* Get to work on the important stuff.

Well that's the easiest part. Just go and do stuff.

**** TODO Make sure the projects priorities propagate to the tasks :feat:

** Journaling process

*** TODO Add a way to link the day note to the agenda :feat:

Maybe a separate capture template like journal?

** Habits

** File organization

My ~~/org/~ directory should be as clean as possible with only the following files present:

- ~inbox.org~ :: file for incoming notes
- ~agenda.org~ :: file for

** References

- [[https://www.labri.fr/perso/nrougier/GTD/index.html][GET THINGS DONE WITH EMACS]] by NICOLAS P. ROUGIER

*** TODO Add other references :chore:

** Outro :noexport:
#+begin_src elisp
)
#+end_src
* General stuff
** TODO ispell setup works janky across machines :fix:
** TODO Language tool for spell/ortho checking :feat:

Howto [[https://github.com/mhayashi1120/Emacs-langtool][here]]
** DONE Move the file to the root of the project :chore:
CLOSED: [2022-10-07 Fri 19:15]
** TODO Add Excalidraw drawings to the sections :chore:
** TODO Add better faces for priorities :feat:
** STRT Add tangle on save hook :feat:
** TODO Add tangle on pre-commit hook :feat:
** TODO Integrate with TTRSS :feat:
** TODO Add auto-tangle back and forth :feat:
** TODO Record this file's skeleton as default literate project file :feat:
** TODO Add org capture from terminal :feat:
** TODO Add notification mechanisms :feat:

* Project chores
** TODO Rework the flake to minimize rebuilds :chore:
** TODO Add sections for the flake and rest of config :chore:

* Project references
- [[https://zzamboni.org/post/my-doom-emacs-configuration-with-commentary/][Zzamboni literate config]]
- [[https://github.com/Mic92/dotfiles/blob/master/nixpkgs-config/modules/emacs/default.nix][Mic92 dotfiles]], editor service reference. Reference for no-rebuild doom config.
